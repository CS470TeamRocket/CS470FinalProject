//
//  PieceModel.swift
//  Switch Personal
//
//  Created by Zachary Brester on 11/15/17.
//  Copyright Â© 2017 CodeMunkeys. All rights reserved.
//

import Foundation
import SpriteKit


//These two structs are created by Maurice for use in the GameScene
struct PModel {
    let row: Int
    let column: Int
    var imgIdx: Int
    let originalCenter: CGPoint
    var sprite : SKSpriteNode
}

struct AModel {
    let row: Int
    let originalCenter: CGPoint
    let sprite : SKSpriteNode
}

//pieceType: This Enumerated type represents the types of pieces available in the game.
enum pieceType {
    case Planet
    case Moon
    case Alien
    case Satellite
    case Rocket
    case Comet
    //Bonuses
    case Money
    case Bomb
    //
    case Empty //Empty case must ALWAYS be last.
    
    //validPieces(level: Int) -> [pieceType]
    //This function will generate a list of piece types that are available to be generated, based on the level
    //variable which is passed to it. This represents increased piece options, and therefore complexity and
    //difficulty based on the increasing level of the game.
    //Inputs: Int, representing the level of the game.
    //Outputs: [pieceType], an array list of the available pieceTypes.
    func validPieces(level: Int) -> [pieceType] {
        var pieceList = [pieceType]()
        switch(level) {
        case (10...Int.max) :
            
            fallthrough
        case (8...9) :
            
            fallthrough
            
        case (6...7):
            pieceList.append(pieceType.Comet)
            fallthrough
            
        case (4...5):
            
            fallthrough
        case (2...3):
            pieceList.append(pieceType.Rocket)
            fallthrough
        default:
            pieceList.append(pieceType.Alien)
            pieceList.append(pieceType.Planet)
            pieceList.append(pieceType.Satellite)
            pieceList.append(pieceType.Moon)
        }
        
        return pieceList
    }
    //specialPieces(level: Int) -> [pieceType]
    //This function will generate a list of special types available to be generated, based on the level variable
    //which is passed to it. The level is a placeholder, but is not currently used.
    //Inputs: Int, unused.
    //Outputs: [pieceType], a list of available and unlocked special piece types.
    func specialPieces(level: Int) -> [pieceType] {
        //currently doesn't do anything with level
        var pieceList = [pieceType]()
        for i in UserDataHolder.shared.unlockedBonuses {
            pieceList.append(i.getPieceType())
            
        }
        return pieceList
    }
}
//PieceModel
//This class represents a piece on the game board. There are no subclasses for this class.
//Different pieces are represented by a difference in the pieceType variable of the piece.
//Pieces do not move from their position dictated on the board, any swaps between them simply trade information.
//Pieces will only be generated by BoardModel, and only may be deleted by a row being removed during the course of
//gameplay.
class PieceModel : NSObject {
    private let appearanceLevel : Int = 1 //The first level at which the piece may appear.
    //private var row: Int //Index for row
    //private var column: Int //Index for column
    private var myType : pieceType = pieceType.Empty
    required init(valid: [pieceType], special:[pieceType], probSpec: Double/*rowNum: Int, colNum: Int*/) {
         //row = rowNum
         //column = colNum
        super.init()
        genType(valid: valid, special: special, probSpec: probSpec)
    }
    
    //getTextIcon() -> String
    //This is a debugging function that returns a character representing the type of the piece.
    //However, this function was utilized by Maurice in the GameScene to determine piece type of the Sprites, so it
    //was left in.
    //Input: None
    //Output: A String representing the character representation of the piece.
    func getTextIcon() ->String {
        switch(myType) {
        case pieceType.Planet:
            return "P"
        case pieceType.Moon:
            return "M"
        case pieceType.Alien:
            return "A"
        case pieceType.Satellite:
            return "S"
        case pieceType.Rocket:
            return "R"
        case pieceType.Comet:
            return "C"
        case pieceType.Bomb:
            return "*"
        case pieceType.Money:
            return "$"
        case pieceType.Empty:
            return " "
        }
    }
    //Getter for pieceType
    func getType() ->pieceType {
        return myType
    }
    
    //Clears the piece, changing it to Empty.
    func clear() {
        myType = pieceType.Empty
    }
    
    //swap(new: PieceModel)
    //Swaps the type for the type of the given piece, and vice versa.
    //This effectively "moves" the pieces into each others squares, for the purposes of the game.
    //Input: PieceModel, representing the piece to swap with.
    //Output: None
    //On Finish: Pieces have swapped pieceTypes.
    func swap(new: PieceModel) {
        let val = myType
        myType = new.myType
        new.myType = val
    }
    
    //isMatching(other: PieceModel) -> Bool
    //Checks to see if the given piece has the same type as this piece.
    //Input: PieceModel, a piece to compare to
    //Output: true if the pieces have the same pieceType and are not empty. False otherwise
    func isMatching(other: PieceModel) ->Bool {
        if(myType == pieceType.Empty || other.getType() == pieceType.Empty) {
            return false
        }
        return myType == other.getType()
    }
    
    func isEmpty() -> Bool {
        return myType == pieceType.Empty
    }
    
    //genType(valid: [pieceType], special: [pieceType], probSpec: Double)
    //This function randomly assigns a pieceType to this piece. It first checks a percent chance for the piece to
    //be a special piece, and if not, it will choose a random normal piece type.
    //Inputs: valid, This represents the list of normal pieces it may be.
    //special: This represents the list of special pieces it may be.
    //probSpec: This represents the percent chance (represented as decimal 0.0 to 1.0) of the piece being special.
    //Outputs: None
    //On Finish: The piece has been assigned a random pieceType.
    func genType(valid: [pieceType], special: [pieceType], probSpec: Double) {
        if (special.count > 0) && (Int(arc4random_uniform(UInt32(100))) < Int(probSpec * 100)) {
            let index = Int(arc4random_uniform(UInt32(special.count)))
            self.myType = special[index]
        }else{
        let index = Int(arc4random_uniform(UInt32(valid.count)))
        self.myType = valid[index]
        }
    }
    
    /* //Unused work in making a proper weighted die
    func weightedDie(diceSize: Int, weights: [Double]) -> Int{
        let weightSum = reduce(weights, 0, +)
        let random = weightSum * Double(arc4random_uniform(UInt32.max)) / Double(UInt32.max)
        accum += 0.0
        for (i, p) in enumerate(probabilities){
            accum += p
            if random < accum {
                return i
            }
        }
        return (diceSize-1) //floating point error catcher
    }*/
    
}




























// You're welcome.
